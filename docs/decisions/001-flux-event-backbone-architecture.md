# ADR-001: Flux Event Backbone Architecture

**Status:** Accepted
**Date:** 2026-02-10
**Deciders:** Architecture Team

---

## Context

Flux is a universal, append-only event stream backbone designed to provide a shared, time-ordered timeline for data generated by any system. Multiple producers publish immutable events, and multiple consumers observe, replay, and process those events independentlyâ€”without coupling to how the data was acquired or originally used.

**What Flux IS:**
- Event stream backbone (preserve and distribute ordered event history)
- Domain-agnostic (no interpretation of event meaning)
- Append-only (immutable event log)
- Replay-capable (consumers can observe from any point in time)

**What Flux IS NOT:**
- SCADA system
- Control system
- Protocol abstraction layer
- Analytics platform
- Decision engine
- State manager
- Schema validator
- Workflow orchestrator

Flux's sole responsibility is to preserve and distribute events so that tools, agents, services, and humans can observe the same evolving "world state" without owning or redefining it.

---

## Decision

### Core Architecture

**Event Backbone:** NATS with JetStream for persistent, ordered event streams.

**Event Model:** Fixed envelope with opaque payload
- Envelope structure is standardized
- Payload is completely flexible (domain-specific)
- Schema is metadata only (no validation enforced)

**Ordering Guarantee:** Per-stream ordering only
- Events within a stream are time-ordered
- No global ordering across streams
- Consumers use `key` field for finer-grained ordering if needed

**Delivery Semantics:** At-least-once delivery with acknowledgements
- Producers publish and receive confirmation
- Consumers acknowledge message processing
- Deduplication is consumer responsibility (using `eventId`)

---

## Control Plane vs Data Plane Architecture

**Critical Architectural Principle:** Flux is a control plane + enforcement layer, not a data plane proxy.

### Architecture Layers

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           CONTROL PLANE (Flux Service)          â”‚
â”‚                                                  â”‚
â”‚  â€¢ Validate events (enforce envelope)           â”‚
â”‚  â€¢ Manage streams (conventions, configuration)  â”‚
â”‚  â€¢ Authorize access (publish/subscribe rights)  â”‚
â”‚  â€¢ Facilitate replay (setup consumers)          â”‚
â”‚                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚ manages
                  â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           DATA PLANE (NATS/JetStream)           â”‚
â”‚                                                  â”‚
â”‚  â€¢ Transport events (high-throughput delivery)  â”‚
â”‚  â€¢ Persist events (file-based storage)          â”‚
â”‚  â€¢ Deliver to consumers (queue groups, acks)    â”‚
â”‚  â€¢ Execute replay (sequence/time-based)         â”‚
â”‚                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Event Flow

**Publish:**
```
Producer â†’ Flux Service (validate, authorize) â†’ NATS (publish)
              â†“
         Return eventId + confirmation
```

**Subscribe:**
```
Consumer â†’ Flux Service (authorize, setup) â†’ NATS subscription
                                                   â†“
                                    Consumer reads directly from NATS
```

### Why This Separation Matters

**Performance:**
- Event data does not flow through Flux as a proxy
- NATS handles millions of events/sec without Flux bottleneck
- Flux only validates on publish, not on every read

**Scalability:**
- NATS can scale independently of Flux
- Multiple Flux instances can share validation duties
- Consumers read directly from NATS (parallel, high-throughput)

**Simplicity:**
- Flux focuses on enforcement, not transport
- NATS handles what it's good at (messaging)
- Clear separation of concerns

**Flexibility:**
- Leverage native NATS features (queue groups, wildcards, etc.)
- Can use NATS client optimizations
- Flux doesn't need to implement messaging primitives

### Flux Service Responsibilities (Control Plane)

**What Flux Does:**
- âœ… Validate event structure (enforce envelope fields)
- âœ… Generate UUIDv7 event IDs (if not provided)
- âœ… Create and configure NATS streams (enforce conventions)
- âœ… Authorize publish requests (who can publish to which streams)
- âœ… Authorize subscribe requests (who can read which streams)
- âœ… Facilitate replay (provide correct NATS consumer configuration)
- âœ… Enforce stream naming conventions
- âœ… Manage retention policies

**What Flux Does NOT Do:**
- âŒ Proxy event data (all events flow directly through NATS)
- âŒ Store events (NATS JetStream handles persistence)
- âŒ Route messages (NATS subject routing handles this)
- âŒ Transform or enrich events (payload is opaque)
- âŒ Aggregate or query events (consumers build their own views)
- âŒ Validate payload schemas (schema is metadata only)

### NATS Responsibilities (Data Plane)

**What NATS Does:**
- âš¡ Accept published events (high-throughput ingestion)
- âš¡ Persist events to disk (JetStream file storage)
- âš¡ Deliver events to consumers (queue groups, fan-out)
- âš¡ Handle acknowledgements (at-least-once delivery)
- âš¡ Provide replay (from sequence, timestamp, beginning)
- âš¡ Manage consumer state (durable consumers, offsets)
- âš¡ Handle network transport (TCP, TLS)

**Key Insight:** NATS is not exposed directly to producers/consumers. They interact with Flux APIs, which then use NATS internally.

---

## Event Model

### Flux Event Structure

```json
{
  "eventId": "01933b4e-7c8f-7890-abcd-1234567890ab",
  "stream": "alarms.events",
  "source": "ignition.gateway.prod",
  "timestamp": 1700000123456,
  "key": "Area1/Pump3/HighTemp",
  "schema": "alarm.raise.v1",
  "payload": {
    "severity": "high",
    "value": 92.4,
    "limit": 90.0,
    "message": "Pump temperature high"
  }
}
```

### Field Definitions

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `eventId` | string (UUIDv7) | Yes | Unique, immutable, time-ordered identifier |
| `stream` | string | Yes | Logical stream/namespace (maps to NATS subject) |
| `source` | string | Yes | Producer identity (who emitted the event) |
| `timestamp` | integer | Yes | Event time in Unix epoch milliseconds (producer time) |
| `key` | string | No | Ordering/partition key (consumer metadata only) |
| `schema` | string | No | Schema name + version (e.g., "alarm.raise.v1") |
| `payload` | object | Yes | Domain-specific event data (opaque to Flux) |

### Design Principles

**eventId (UUIDv7):**
- Time-ordered for efficient indexing
- Globally unique across all streams
- Used by consumers for deduplication

**stream:**
- Initially maps 1:1 to NATS subject
- Hierarchical naming convention (e.g., `alarms.events`, `sensor.readings.hvac`)
- Flexibility for future evolution (subject mapping may change)

**source:**
- Identifies the producer system
- Useful for debugging, auditing, filtering
- No enforcement by Flux (trust-based)

**timestamp:**
- Producer's event time (not Flux ingestion time)
- Enables time-based replay
- Clock skew is producer responsibility

**key (optional):**
- Consumer-side metadata for ordering/grouping
- Examples: asset ID, tag path, symbol, device serial
- Flux does not route or partition by key
- Consumers can order events within a stream by key

**schema (optional):**
- Metadata onlyâ€”Flux does not validate
- Consumer responsibility to handle versioning
- Enables schema evolution without Flux changes

**payload:**
- Opaque JSON object
- Domain-specific structure
- Flux does not inspect or transform

---

## Producer Interface

### Flux Service API

Producers publish events through the Flux Service, which validates and forwards to NATS:

**Flow:**
1. Producer sends event to Flux Service
2. Flux validates envelope structure
3. Flux generates `eventId` if not provided (UUIDv7)
4. Flux authorizes publish (stream permissions)
5. Flux publishes to NATS JetStream
6. Flux returns confirmation (eventId, sequence number)

```python
# Example: Python producer using Flux client
import flux_client
import time

client = flux_client.FluxClient("flux://flux-server:8090")

event = {
    "stream": "alarms.events",
    "source": "plant-a.scada",
    "timestamp": int(time.time() * 1000),
    "key": "Pump3/HighTemp",
    "schema": "alarm.raise.v1",
    "payload": {
        "severity": "high",
        "value": 92.4
    }
}

# Flux validates, generates eventId, publishes to NATS
result = await client.publish(event)
print(f"Published: {result.event_id}")
```

**What Happens Inside Flux Service:**
```python
# Flux service internal logic (pseudo-code)
def handle_publish(event):
    # 1. Validate envelope
    validate_required_fields(event)

    # 2. Generate eventId if missing
    if not event.get("eventId"):
        event["eventId"] = generate_uuid_v7()

    # 3. Authorize
    if not can_publish(user, event["stream"]):
        raise Unauthorized()

    # 4. Publish to NATS
    nats_client.publish(event["stream"], json.dumps(event))

    # 5. Return confirmation
    return {"eventId": event["eventId"], "stream": event["stream"]}
```

**Requirements:**
- Producers must provide: `stream`, `source`, `timestamp`, `payload`
- `eventId` is optional (Flux generates if missing)
- No direct NATS access (Flux handles internally)

**Delivery Confirmation:**
- Flux returns `eventId` and stream on success
- Producers should handle retries on Flux Service failure
- NATS acknowledgement is internal (handled by Flux)

### Protocol Options

**Phase 1:** Native protocol (likely gRPC or custom over TCP)
- Fast, efficient binary protocol
- Direct integration with Flux Service
- Used by Flux client libraries

**Phase 2:** HTTP/REST API (future consideration)
- For broader adoption (web browsers, simple clients)
- Thin wrapper over native protocol

```http
POST /api/events
Content-Type: application/json

{
  "stream": "alarms.events",
  "source": "external-system",
  "timestamp": 1700000123456,
  "key": "optional-key",
  "schema": "optional-schema",
  "payload": { ... }
}
```

Response includes generated `eventId`.

---

## Consumer Interface

### Flux Service Facilitation + Direct NATS Read

Consumers request authorization from Flux, then read directly from NATS:

**Flow:**
1. Consumer requests subscription from Flux Service
2. Flux authorizes access (stream permissions)
3. Flux provides NATS connection details and consumer config
4. **Consumer reads events directly from NATS** (not through Flux)
5. Consumer acknowledges messages to NATS

```python
# Example: Python consumer using Flux client
import flux_client
import nats

# 1. Request subscription from Flux
client = flux_client.FluxClient("flux://flux-server:8090")

subscription_config = await client.request_subscription(
    stream="alarms.events",
    consumer_name="alarm-processor",
    replay_from="beginning"  # or timestamp, or "latest"
)

# 2. Flux returns NATS connection details
# {
#   "nats_url": "nats://nats-internal:4222",
#   "stream": "alarms.events",
#   "consumer": "alarm-processor",
#   "credentials": "..."
# }

# 3. Consumer connects directly to NATS
nc = await nats.connect(subscription_config["nats_url"],
                        credentials=subscription_config["credentials"])
js = nc.jetstream()

# 4. Subscribe and read directly from NATS
sub = await js.subscribe(subscription_config["stream"],
                         durable=subscription_config["consumer"])

async for msg in sub.messages:
    event = json.loads(msg.data)
    # Process event...
    await msg.ack()  # Acknowledge directly to NATS
```

**Key Points:**
- Flux authorizes and facilitates, but does not proxy data
- Consumers read events directly from NATS (high throughput)
- NATS handles delivery, acknowledgements, replay
- Flux provides connection setup only

**What Happens Inside Flux Service:**
```python
# Flux service internal logic (pseudo-code)
def handle_subscribe_request(user, stream, consumer_name, replay_from):
    # 1. Authorize
    if not can_subscribe(user, stream):
        raise Unauthorized()

    # 2. Create or verify NATS consumer exists
    ensure_nats_consumer(stream, consumer_name, replay_from)

    # 3. Return NATS connection details
    return {
        "nats_url": "nats://internal:4222",
        "stream": stream,
        "consumer": consumer_name,
        "credentials": generate_nats_credentials(user)
    }
```

**Filtering:**
- By stream (NATS subject wildcards: `alarms.*`, `sensor.>`)
- By time (Flux configures replay timestamp on consumer setup)
- By key/schema (consumer-side filtering after receiving)

**Consumer Groups:**
- JetStream durable consumers (NATS feature)
- Multiple instances share workload automatically
- Each message delivered to one consumer in the group

### Protocol Options

**Phase 1:** Native protocol (likely gRPC or custom over TCP)
- Efficient authorization and connection setup
- Returns NATS connection details
- Used by Flux client libraries

**Phase 2:** HTTP/WebSocket API (future consideration)
- For web browsers and simple clients
- WebSocket for real-time streaming
- HTTP for subscription setup

Note: Even with HTTP/WebSocket, actual event delivery would still be via NATS for performance (or WebSocket streaming for constrained clients).

---

## Replay Capabilities

Flux facilitates replay by configuring NATS consumers. NATS executes the actual replay.

**Replay Options:**
1. **Beginning of stream** (from first event)
2. **Specific timestamp** (from a point in time)
3. **Sequence number** (from a specific position)
4. **Last received** (resume from last processed event)

**Example: Replay from 1 hour ago**
```python
# Request subscription from Flux with replay
subscription_config = await client.request_subscription(
    stream="alarms.events",
    consumer_name="replayer",
    replay_from={
        "type": "timestamp",
        "value": int((time.time() - 3600) * 1000)  # 1 hour ago
    }
)

# Flux creates NATS consumer configured for replay
# Consumer reads directly from NATS starting at that timestamp
nc = await nats.connect(subscription_config["nats_url"])
js = nc.jetstream()
sub = await js.subscribe(subscription_config["stream"],
                         durable=subscription_config["consumer"])

# Events are replayed from 1 hour ago
async for msg in sub.messages:
    event = json.loads(msg.data)
    # Process historical event...
    await msg.ack()
```

**How Replay Works:**
1. Consumer requests subscription from Flux with replay parameters
2. Flux creates NATS consumer with appropriate start position
3. NATS delivers historical events from that position
4. Consumer reads events directly from NATS (high throughput)

**No Query API:**
- Flux does not provide SQL-like queries
- Replay is stream-based only (sequential read from position)
- Consumers build their own views/indexes if needed

---

## Retention & Storage

**Retention is operational configuration, not a core architectural decision.**

Default retention policies per stream:
- **Time-based:** 7 days (configurable per stream)
- **Size-based:** 10GB max per stream (configurable)
- **Message count:** 10 million messages max (configurable)

Storage backend:
- JetStream file-based persistence
- Automatic cleanup when limits reached

**Configuration:**
```bash
# Example: Create stream with custom retention
nats stream add ALARMS \
  --subjects "alarms.*" \
  --retention limits \
  --max-age 30d \
  --max-bytes 50GB \
  --storage file
```

Retention policies are deployment-specific and can be adjusted without changing Flux architecture.

---

## Authorization & Security

**Simple NATS ACLs for stream-level permissions.**

**Publisher ACLs:**
```
publish = {
  allow: ["alarms.>", "sensor.>"]
}
```

**Subscriber ACLs:**
```
subscribe = {
  allow: ["alarms.>"]
}
```

**Phase 1 Scope:**
- Basic NATS authentication (username/password or token)
- Stream-level ACLs (who can publish/subscribe to which streams)
- TLS encryption in transit

**Explicitly Out of Scope (Phase 1):**
- Role-based access control (RBAC)
- Fine-grained permissions (per-source, per-key filtering)
- OAuth/OIDC integration
- Audit logging

Advanced auth can be added later without changing core architecture.

---

## Ordering Guarantees

**Critical Principle: Ordering is per-stream, not global.**

**Within a stream:**
- Events are totally ordered by `timestamp` and sequence
- Consumers see events in publish order
- Replay preserves this order

**Across streams:**
- No ordering guarantee
- Events in `alarms.events` and `sensor.readings` are independent
- Consumers correlate using `timestamp` if needed

**Consumer-Side Ordering:**
- Use `key` field to group related events
- Example: All events with `key="Pump3"` can be ordered by `timestamp`
- Flux does not enforce key-based ordering

---

## What We Are NOT Building (Phase 1)

Explicitly out of scope to maintain focus on core event backbone:

- âŒ Schema validation or registry
- âŒ Event transformation or enrichment
- âŒ State management or caching
- âŒ Complex authorization (RBAC, ABAC)
- âŒ Query APIs (SQL, GraphQL)
- âŒ Analytics or aggregations
- âŒ Workflow orchestration
- âŒ Protocol adapters (OPC-UA, Modbus, etc.)
- âŒ Admin UI (beyond basic NATS CLI)

These capabilities may be built as separate systems that consume Flux events.

---

## Consequences

### Positive

âœ… **Domain-agnostic** - Works for any event type (SCADA, IoT, finance, logistics)
âœ… **High performance** - NATS data plane handles 11M+ msgs/sec without Flux bottleneck
âœ… **Scalable** - Control plane (Flux) and data plane (NATS) scale independently
âœ… **Enforced conventions** - Flux validates event structure, NATS handles transport
âœ… **Replay-capable** - Consumers can reprocess history from any point
âœ… **Flexible schema** - No central schema validation bottleneck
âœ… **Decoupled producers/consumers** - Systems evolve independently
âœ… **Simple mental model** - Flux validates, NATS moves data

### Negative

âš ï¸ **No cross-stream ordering** - Applications needing global order must correlate
âš ï¸ **No schema enforcement** - Bad events can be published (consumer problem)
âš ï¸ **At-least-once only** - Consumers must handle duplicates
âš ï¸ **No built-in querying** - Consumers build their own indexes/views
âš ï¸ **Clock skew possible** - Producer timestamps may not align perfectly

### Neutral

ðŸ“ **Retention is operational** - Must configure per deployment
ðŸ“ **Simple auth** - May need to add RBAC later
ðŸ“ **Native protocol** - HTTP/REST API may be added for broader adoption
ðŸ“ **Stream = subject initially** - May evolve mapping strategy later
ðŸ“ **Control plane overhead** - Validation adds latency on publish (minimal impact)

---

## Implementation Notes

### Technology Stack

**Flux Service (Control Plane):**
- **Language:** Go
- **Rationale:** Excellent NATS client library, compiled binary, good for network services
- **Components:** Event validator, stream manager, authorization layer

**NATS (Data Plane):**
- **Product:** NATS with JetStream
- **Rationale:** High-performance message broker, 11M+ msgs/sec, built-in persistence and replay

**Client Examples:**
- **Language:** Python (initially)
- **Rationale:** Accessible, good for documentation and examples

### Stream Naming Conventions

Recommended hierarchical naming:
- `domain.type` (e.g., `alarms.events`, `sensor.readings`)
- `domain.subdomain.type` (e.g., `sensor.hvac.temperature`)
- Use lowercase with dots for hierarchy
- Enables wildcard subscriptions (`sensor.*`, `alarms.>`)

### JetStream Configuration

Default stream settings:
- **Storage:** File (persistent)
- **Retention:** Limits-based (time + size)
- **Replicas:** 1 (single-node initially)
- **Max message size:** 1MB (adjust if needed)

### Monitoring

Expose Prometheus metrics for:
- Events published per stream (rate, count)
- Events consumed per stream (rate, count)
- Stream storage usage (bytes, messages)
- Consumer lag (messages behind)

---

## References

- [NATS JetStream Documentation](https://docs.nats.io/jetstream)
- [UUIDv7 Specification](https://datatracker.ietf.org/doc/draft-ietf-uuidrev-rfc4122bis/)
- Related project: `/projects/flux-reactor` (SCADA-specific implementation)

---

## Revision History

- **2026-02-10:** Initial decision - Event backbone architecture
- **2026-02-10 (updated):** Added control plane vs data plane architecture distinction - Flux Service as enforcement layer over NATS data plane
