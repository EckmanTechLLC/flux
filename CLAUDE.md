# Flux Context for Claude

**Last Updated:** 2026-02-11
**Current Phase:** Initial Setup

---

## Quick Reference

**Project:** Flux - Universal append-only event stream backbone
**Architecture:** NATS/JetStream with standardized event envelope
**Key Docs:**
- `/docs/decisions/001-flux-event-backbone-architecture.md` - Core architecture and event model
- `/docs/workflow/multi-session-workflow.md` - Development workflow

---

## User Preferences (Apply Always)

- **Never be verbose** - clear, concise responses
- **Small, incremental changes** - don't build everything at once
- **Ask before expanding scope** - stay within defined task
- **Document as you go** - ADRs for decisions, session notes for progress
- **Show, don't just talk about it**
- **Always check the codebase** - read files, never rely on memory
- **Research before suggesting** - check docs/libraries, don't guess
- **Plan before implementing** - get approval on approach first

---

## Current Status

### Initial Setup (IN PROGRESS üü°)
- [x] Documentation structure created
- [x] Multi-session workflow established
- [x] Core architecture decision (ADR-001)
- [x] NATS/JetStream infrastructure setup
- [x] Event model implementation (structs, validation, tests)
- [x] Stream management (create, configure, initialize on startup)
- [x] Publish API implementation (validate, auto-create stream, publish to NATS)
- [ ] Example consumer implementation
- [ ] Getting started documentation

**Infrastructure Ports:**
- NATS client: 4223 (external) ‚Üí 4222 (internal)
- NATS monitoring: 8223
- Flux service: 8090

---

## What Flux IS

**Flux is a universal, append-only event stream backbone** that provides a shared, time-ordered timeline for data generated by any system.

**Core Characteristics:**
- **Domain-agnostic** - No interpretation of event meaning
- **Append-only** - Immutable event log
- **Replay-capable** - Consumers can observe from any point in time
- **Decoupled** - Producers and consumers operate independently
- **Ordered per-stream** - Events within a stream are time-ordered (not globally)

**Event Model:**
- Fixed envelope with opaque payload
- Schema is metadata only (no validation)
- UUIDv7 event IDs (time-ordered)
- At-least-once delivery semantics

---

## What Flux IS NOT

Flux does not:
- ‚ùå Act as a SCADA system, control system, or protocol abstraction layer
- ‚ùå Interpret meaning, enforce workflows, or normalize domains
- ‚ùå Validate schemas or transform events
- ‚ùå Manage state or provide caching
- ‚ùå Provide complex authorization (Phase 1)
- ‚ùå Offer SQL/query APIs (stream replay only)

Flux's sole responsibility is to preserve and distribute the ordered history of events.

---

## Key Decisions

**Core Architecture (ADR-001):**
- NATS with JetStream as event backbone
- Fixed envelope: `eventId`, `stream`, `source`, `timestamp`, `key`, `schema`, `payload`
- Direct NATS client as primary interface (HTTP optional later)
- Per-stream ordering only (not global)
- At-least-once delivery with consumer acknowledgements
- Simple NATS ACLs for authorization

**Technology Stack:**
- **Message Bus:** NATS with JetStream (internal backend)
- **Flux Service:** Go ‚úÖ
- **Storage:** JetStream file-based persistence
- **Deployment:** Docker Compose (initial), Kubernetes (future)
- **Monitoring:** Prometheus metrics (basic)
- **Client Examples:** Python

**Related Projects:**
- `/projects/flux-reactor` - SCADA-specific implementation using similar patterns
- Flux extracts the event streaming backbone without domain interpretation

**Development Environment:**
- This is a shared dev server with multiple active projects
- Must not disrupt other running services
- Use specific ports, document resource usage
- Easy to start/stop without affecting other projects
- Docker Compose must be non-invasive

---

## What NOT to Do

- Don't implement without explicit plan approval
- Don't guess at solutions - research first
- Don't use memory - always read files
- Don't add features not requested
- Don't be verbose in responses or documentation
- Don't interpret event payloads (Flux is payload-agnostic)
- Don't add schema validation (out of scope)

---

## Implementation Session Checklist

**For EVERY code change, follow this checklist:**

### 1. READ FIRST
- [ ] Read CLAUDE.md (this file) to understand context
- [ ] Read relevant ADR(s) for the feature area
- [ ] Read existing code files you'll modify
- [ ] Verify your understanding of current state

### 2. VERIFY ASSUMPTIONS
- [ ] Check if files/functions exist where you expect
- [ ] Verify API endpoints/interfaces match your assumptions
- [ ] Confirm dependencies are available
- [ ] List what you'll change BEFORE making changes

### 3. MAKE CHANGES
- [ ] Make ONE logical change at a time
- [ ] Keep changes small and focused
- [ ] Follow existing code patterns and style
- [ ] Add/update tests for changed behavior
- [ ] Update relevant documentation

### 4. TEST & VERIFY
- [ ] Tests pass, no regressions
- [ ] Document expected test results
- [ ] Provide test commands for user to run

### 5. DOCUMENT
- [ ] Update session notes with what was done
- [ ] Note any issues encountered and how resolved
- [ ] List files created/modified
- [ ] Update CLAUDE.md if status changed

### 6. REPORT
- [ ] Provide concise summary to user
- [ ] Report any blockers or questions
- [ ] Confirm scope was not exceeded
- [ ] List next steps if applicable

**If you skip any step, you're doing it wrong.**

---

## Session Start Protocol

1. **User provides task**: Specific, bounded scope
2. **You confirm**: Restate task, list files you'll touch, ask for approval
3. **You work**: Follow checklist above
4. **You report**: Summary + session notes location
5. **Foundation verifies**: Reads files, confirms correctness
6. **Next task**: Foundation provides prompt for next session

---

## Phase 1 Scope (Minimal Viable Flux)

**Goal:** Control plane that enforces Flux conventions over NATS

**Core Deliverables:**
1. **Flux Service** (Go binary/container) - Control Plane
   - Event validation API (enforce envelope, generate UUIDv7)
   - Publish API (validate ‚Üí publish to NATS ‚Üí return confirmation)
   - Subscribe setup API (authorize ‚Üí return NATS connection details)
   - Stream management (create/configure streams with Flux conventions)
   - Basic authorization (who can publish/subscribe to which streams)

2. **Infrastructure**
   - Docker Compose (Flux service + NATS, non-invasive)
   - Port allocation (avoid conflicts with other projects)
   - Resource limits (low CPU/memory footprint)
   - Easy start/stop

3. **Client Examples** (Python)
   - Producer: Flux validation ‚Üí NATS publish
   - Consumer: Flux authorization ‚Üí NATS subscription (direct)
   - Replay demonstration (from timestamp, sequence)

4. **Documentation**
   - Getting Started (run Flux, publish/consume)
   - API documentation (control plane interfaces)
   - Event model specification
   - Port usage and resource requirements

**What We're NOT Building (Phase 1):**
- ‚ùå Flux as data proxy (NATS handles data plane)
- ‚ùå HTTP REST API (gRPC or native NATS protocol)
- ‚ùå Advanced auth (RBAC, OIDC)
- ‚ùå Client SDK libraries (examples only)
- ‚ùå Monitoring dashboard
- ‚ùå Admin UI

**Language Decision:**
- **Flux Service:** Go ‚úÖ (decided)
- **Client Examples:** Python

---

## What "Flux" Actually Is

**Flux is a control plane + enforcement layer**, not a data plane proxy.

**Architecture:**
```
Producer ‚Üí Flux (validate, authorize) ‚Üí NATS (publish event)
Consumer ‚Üí Flux (authorize, setup) ‚Üí NATS (read events directly)
                                         ‚Üë
                                    Data plane
```

**Control Plane (Flux manages):**
- ‚úÖ Event validation (enforce envelope structure, UUIDv7)
- ‚úÖ Stream management (create/configure streams, conventions)
- ‚úÖ Access control (authorize publish/subscribe)
- ‚úÖ Replay facilitation (setup consumers with correct options)
- ‚úÖ Convention enforcement (naming, retention policies)

**Data Plane (NATS handles):**
- ‚ö° Event transport (high-throughput message delivery)
- ‚ö° Event persistence (file-based storage)
- ‚ö° Consumer delivery (queue groups, acknowledgements)
- ‚ö° Replay execution (sequence-based, time-based)

**Key Principle:** Flux validates and authorizes, NATS moves data.

**Why this matters:**
- Performance: Data doesn't bottleneck through Flux
- Scalability: NATS handles millions of events/sec
- Simplicity: Flux is lightweight, focused
- Flexibility: Leverage NATS features directly

---

## Known Issues

None yet (fresh project)

---

## Code Quality Standards

**General:**
- No TODOs in code (track in issues/ADRs)
- No commented-out code
- Clear variable/function names
- Keep functions small (<100 lines)

**Example Code (Python/Go/Rust):**
- Follow language conventions
- Include error handling
- Add inline comments for complex logic
- Provide usage examples in README
